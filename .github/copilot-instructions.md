# AI Copilot Instructions for FTMS Flutter App

## Project Overview
PowerTrain (FTMS) is a Flutter fitness app for controlling FTMS-compatible machines (rowers, indoor bikes) via Bluetooth Low Energy. 


## Role of AI Copilot
You are an expert Flutter developer with deep knowledge of:
- FTMS protocol (Fitness Machine Service)
- Bluetooth Low Energy (BLE) device communication
- Flutter state management patterns
- Fitness training session logic
- Localization (i18n) in Flutter
- Testing patterns for Flutter apps


## Always Follow These Guidelines
- Use SOLID principles
- Write clean, maintainable, well-documented code
- All code must be tested with unit tests. Coverage must be at least 80%

## Architecture Patterns

### Service Layer (Singleton Pattern)
All business logic lives in `/lib/**/services/`. Services use singleton factories:

**Rule**: Always use singletons for services; inject dependencies in constructor for testability.

### Device Management (Abstraction + Facades)
Bluetooth device management (`lib/core/services/devices/`) uses facade pattern to abstract complex FTMS/BLE logic:
- `bt_device.dart` - Abstract base for all device types (Hrm, Cadence, Ftms)
- `FlutterBluePlusFacade` / `FtmsFacade` - Abstractions over flutter_blue_plus and flutter_ftms
- `SupportedBTDeviceManager` - Singleton managing all connected devices

### State Management (No BLoC Redux)
The app uses a **minimal state approach** (not full BLoC with events):
- `lib/core/bloc/ftms_bloc.dart` - Exists but may not be fully utilized; check before adding new BLoC logic
- Prefer direct service calls + `StreamBuilder`/`FutureBuilder` for UI updates
- Example: `SessionSelectorService` manages training session state directly


## Critical Workflows

### Training session flow
1. User selects session in `FtmsSessionSelectorTab` - free ride, training session generator or saved training session definition
2. `SessionSelectorService` creates `TrainingSessionDefinition`
3. 'TrainingSessionController' manages session state, progress, and device interaction, session start, stop, machine control, resistance changes, etc.

### Data communication with FTMS device
1. Ftms class handles the communication with the FTMS device via GATT characteristics
2. _detectFtmsMachineTypeAndConnectToDataStream identifies machine type and sets up data streams
3. Data received from the device is parsed by FtmsDataProcessor

### Device data configuration
1. in lib/config folder there are configuration files for different devices
2. LiveDataFieldValue maps configuration from lib/config to the displayed values in the app

### Run locally
```bash
flutter run -d macos
```

### Run tests

```bash
flutter test
```

### Build & Release
```bash
flutter build appbundle --release  # Play Store
```

Generated files:
- `build/app/outputs/bundle/release/app-release.aab` (Play Store)
@
### Localization (i18n)
- ARB files: `lib/l10n/intl_{en,fr,de}.arb`
- Generated class: `AppLocalizations` (auto-generated by `flutter gen-l10n`)
- Usage: `AppLocalizations.of(context)!.translationKey`
- **Rule**: Always run `flutter gen-l10n` after updating ARB files

### Testing
Tests live in `test/` mirroring `lib/` structure:
- `test/core/` - Service unit tests
- `test/features/` - Feature logic tests
- `test_fit_files/` - Test data (FIT format files)

Example test pattern for singletons:
```dart
// Use .forTesting() constructor for dependency injection
final manager = SupportedBTDeviceManager.forTesting(
  flutterBluePlusFacade: mockFacade,
  ftmsFacade: mockFtms,
);
```

## Project-Specific Conventions

### File Organization
- `/lib/core/` - Shared services, models, BLoC, utilities, widgets
- `/lib/features/` - Feature-specific screens, widgets, services
- Each feature folder: `models/`, `services/`, `widgets/`, and screens as root files
- Example: `lib/features/training/training_session_progress_screen.dart`

### Naming & Casing
- Enums: `UPPER_CASE` allowed (see `analysis_options.yaml`)
- Models: Classes prefixed with descriptive type (e.g., `ExpandedTrainingSessionDefinition`)
- Services: Always `*Service` suffix

### Bluetooth Device Types
Three device types supported:
1. **Hrm** - Heart Rate Monitor
2. **Cadence** - Cadence sensor (bikes only)
3. **Ftms** - Fitness Machine (rower/bike trainer)

All extend `BTDevice` and implement characteristic reading/writing via GATT services.

### Resistance Levels & Machine Types
- **Rowers**: Default: min 10, max 150, increment 10. This is used as a basis for Domyos rowers and translated to other machines ranges.
- **Bikes**: Resistance = 0-100 percentage
- `DeviceType` enum: `rower`, `indoorBike` (see models/device_types.dart)

## External Dependencies
- **flutter_blue_plus** - BLE scanning/connection (wrapped by `FlutterBluePlusFacade`)
- **flutter_ftms** - FTMS protocol parsing (wrapped by `FtmsFacade`)
- **firebase_core** + **firebase_analytics** - Analytics (must init in main.dart)
- **fit_tool** - FIT file generation for workouts


## Key Files to Read First
- `lib/main.dart` - Firebase init, app structure
- `lib/config/*`- Device configurations and user preferences
- `lib/core/services/devices/bt_device_manager.dart` - Device lifecycle, scanning
- `lib/core/services/devices/ftms.dart` - FTMS device communication logic
- `lib/features/ftms/services/session_selector_service.dart` - Training session logic
- `lib/core/services/analytics/analytics_service.dart` - Event tracking patterns
- `lib/features/training/training_session_controller.dart` - Training session state management

